CONTEXT-FREE GRAMMAR (CFG)
--------------------------

A context-free grammar is a 4-tuple (V,Î£,R,S), where

  1. V is a finite set called the variables,
  2. Î£ is a finite set, disjoint from V, called the terminals,
  3. R is a finite set of rules, with each rule being a variable and a
     string of variables and terminals, and
  4. S âˆˆ V is the start variable.


DESIGNING CONTEXT-FREE GRAMMARS
-------------------------------

As with the design of finite automata, the design of context-free
grammars requires creativity. Indeed, context-free grammars are even
trickier to construct than finite automata because we are more
accustomed to programming a machine for specific tasks than we are to
describing languages with grammars. The following techniques are
helpful, singly or in combination, when youâ€™re faced with the problem
of constructing a CFG.

First, many CFLs are the union of simpler CFLs. If you must construct
a CFG for a CFL that you can break into simpler pieces, do so and then
construct individual grammars for each piece. These individual
grammars can be easily merged into a grammar for the original language
by combining their rules and then adding the new rule Sâ†’Sâ‚|Sâ‚‚|Â·Â·Â·|Sâ‚‘,
where the variables Sáµ¢ are the start variables for the individual
grammars. Solving several simpler problems is often easier than
solving one complicated problem.

Second, constructing a CFG for a language that happens to be regular
is easy if you can first construct a DFA for that language. You can
convert any DFA into an equivalent CFG as follows. Make a variable Ri
for each state qi of the DFA. Add the rule Ráµ¢â†’aRâ±¼ to the CFG if
Î´(qáµ¢,a)=qâ±¼ is a transition in the DFA. Add the rule Ráµ¢â†’Îµ if qi is an
accept state of the DFA. Make Râ‚€ the start variable of the grammar,
where qâ‚€ is the start state of the machine. Verify on your own that
the resulting CFG generates the same language that the DFA recognizes.

Third, certain context-free languages contain strings with two
substrings that are â€œlinkedâ€ in the sense that a machine for such a
language would need to remember an unbounded amount of information
about one of the substrings to verify that it corresponds properly to
the other substring. This situation occurs in the language
{0â¿1â¿|nâ‰¥0} because a machine would need to remember the number of 0s
in order to verify that it equals the number of 1s. You can construct
a CFG to handle this situation by using a rule of the form Râ†’uRv,
which generates strings wherein the portion containing the uâ€™s
corresponds to the portion containing the vâ€™s.

Finally, in more complex languages, the strings may contain certain
structures that appear recursively as part of other (or the same)
structures. To achieve this effect, place the variable symbol
generating the structure in the location of the rules corresponding to
where that structure may recursively appear.


CHOMSKY NORMAL FORM
-------------------

A context-free grammar is in Chomsky normal form if every rule is of
the form

  1. A â†’ BC
  2. A â†’ a

where a is any terminal and A, B, and C are any variables â€”- except
that B and C may not be the start variable. In addition, we permit the
rule S â†’ Îµ, where S is the start variable.

Any context-free language is generated by a context-free grammar in
Chomsky normal form.

PROOF IDEA:

We can convert any grammar G into Chomsky normal form.  The conversion
has several stages wherein rules that violate the conditions are
replaced with equivalent ones that are satisfactory. First, we add a
new start variable. Then, we eliminate all Îµ-rules of the form Aâ†’Îµ. We
also eliminate all unit rules of the form Aâ†’B. In both cases we patch
up the grammar to be sure that it still generates the same
language. Finally, we convert the remaining rules into the proper
form.

PROOF:

First, we add a new start variable Sâ‚€ and the rule Sâ‚€â†’S, where S was
the original start variable. This change guarantees that the start
variable doesnâ€™t occur on the right-hand side of a rule.  Second, we
take care of all Îµ-rules. We remove an Îµ-rule Aâ†’Îµ, where A is not the
start variable. Then for each occurrence of an A on the right-hand
side of a rule, we add a new rule with that occurrence deleted. In
other words, if Râ†’uAv is a rule in which u and v are strings of
variables and terminals, we add rule Râ†’uv. We do so for each
occurrence of an A, so the rule Râ†’uAvAw causes us to add Râ†’uvAw,
Râ†’uAvw, and Râ†’uvw. If we have the rule Râ†’A, we add Râ†’Îµ unless we had
previously removed the rule Râ†’Îµ. We repeat these steps until we
eliminate all Îµ-rules not involving the start variable. Third, we
handle all unit rules. We remove a unit rule Aâ†’B. Then, whenever a
rule Bâ†’u appears, we add the rule Aâ†’u unless this was a unit rule
previously removed. As before, u is a string of variables and
terminals. We repeat these steps until we eliminate all unit rules.
Finally, we convert all remaining rules into the proper form. We
replace each rule Aâ†’uâ‚uâ‚‚Â·Â·Â·uâ‚‘, where eâ‰¥3 and each ui is a variable or
terminal symbol, with the rules Aâ†’uâ‚Aâ‚, Aâ‚â†’uâ‚‚Aâ‚‚, Aâ‚‚â†’uâ‚ƒAâ‚ƒ, ..., and
Aâ‚‘â‚‹â‚‚â†’uâ‚‘â‚‹â‚uâ‚‘. The Aáµ¢â€™s are new variables. We replace any terminal uáµ¢ in
the preceding rule(s) with the new variable Uáµ¢ and add the rule Uáµ¢â†’uáµ¢.


PUSHDOWN AUTOMATON (PDA)
------------------------

A pushdown automaton is a 6-tuple (Q,Î£,Î“,Î´,qâ‚€,F), where Q, Î£, Î“, and F
are all finite sets, and

  1. Q is the set of states,
  2. Î£ is the input alphabet,
  3. Î“ is the stack alphabet,
  4. Î´: Q Ã— Î£Îµ Ã— Î“Îµ â†’ ð’«(QÃ—Î“Îµ) is the transition function,
  5. qâ‚€ âˆˆ Q is the start state, and
  6. F âŠ† Q is the set of accept states.

A pushdown automaton M=(Q,Î£,Î“,Î´,qâ‚€,F) computes as follows. It accepts
input w if w can be written as w=wâ‚wâ‚‚Â·Â·Â·wâ‚‘, where each wáµ¢âˆˆÎ£Îµ and
sequences of states râ‚€,râ‚,...,râ‚‘ âˆˆ Q and strings sâ‚€,sâ‚,...,sâ‚‘ âˆˆ Î“âˆ—
exist that satisfy the following three conditions. The strings sáµ¢
represent the sequence of stack contents that M has on the accepting
branch of the computation.

  1. râ‚€=qâ‚€ and sâ‚€=Îµ. This condition signifies that M starts out
     properly, in the start state and with an empty stack.
  2. For i=0,...,eâˆ’1, we have (ráµ¢â‚Šâ‚,b) âˆˆ Î´(ráµ¢,wáµ¢â‚Šâ‚,a), where sáµ¢=at and
     sáµ¢â‚Šâ‚=bt for some a,bâˆˆÎ“Îµ and tâˆˆÎ“*. This condition states that M
     moves properly according to the state, stack, and next input
     symbol.
  3. râ‚‘âˆˆF. This condition states that an accept state occurs at the
     input end.


PUSHDOWN AUTOMATON IS EQUIVALENT WITH CONTEXT-FREE GRAMMARS
-----------------------------------------------------------

  1. If a language is context free, then some pushdown automaton
     recognizes it.

  2. If a pushdown automaton recognizes some language, then it is
     context free.

Because every regular language is recognized by a finite automaton and
every finite automaton is automatically a pushdown automaton that
simply ignores its stack, we now know that every regular language is
also a context-free language.


THE PUMPING LEMMA FOR CONTEXT-FREE LANGUAGES
--------------------------------------------

If A is a context-free language, then there is a number p (the pumping
length) where, if s is any string in A of length at least p, then s
may be divided into five pieces s = uvxyz satisfying the conditions

  1. for each i â‰¥ 0, uvâ±xyâ±z âˆˆ A,
  2. |vy| > 0, and
  3. |vxy| â‰¤ p.


DETERMINISTIC PUSHDOWN AUTOMATON
--------------------------------

A deterministic pushdown automaton is a 6-tuple (Q,Î£,Î“,Î´,qâ‚€,F), where
Q, Î£, Î“, and F are all finite sets, and

  1. Q is the set of states,
  2. Î£ is the input alphabet,
  3. Î“ is the stack alphabet,
  4. Î´: Q Ã— Î£Îµ Ã— Î“Îµ â†’ (QÃ—Î“Îµ)âˆª{âˆ…} is the transition function,
  5. qâ‚€ âˆˆ Q is the start state, and
  6. F âŠ† Q is the set of accept states.

The transition function Î´ must satisfy the following condition. For
every qâˆˆQ, aâˆˆÎ£, and xâˆˆÎ“, exactly one of the values Î´(q,a,x), Î´(q,a,Îµ),
Î´(q,Îµ,x), and Î´(q,Îµ,Îµ) is not âˆ….

The transition function may output either a single move of the form
(r,y) or it may indicate no action by outputting âˆ….

To illustrate these possibilities, letâ€™s consider an example. Suppose
a DPDA M with transition function Î´ is in state q, has a as its next
input symbol, and has symbol x on the top of its stack. If
Î´(q,a,x)=(r,y) then M reads a, pops x off the stack, enters state r,
and pushes y on the stack.

Alternatively, if Î´(q,a,x)=âˆ… then when M is in state q, it has
no move that reads a and pops x. In that case, the condition on Î´
requires that one of Î´(q,Îµ,x), Î´(q,a,Îµ), or Î´(q,Îµ,Îµ) is nonempty, and
then M moves accordingly. The condition enforces deterministic
behavior by preventing the DPDA from taking two different actions in
the same situation, such as would be the case if both Î´(q,a,x)â‰ âˆ… and
Î´(q,a,Îµ)â‰ âˆ….

A DPDA has exactly one legal move in every situation where its stack
is nonempty. If the stack is empty, a DPDA can move only if the
transition function specifies a move that pops Îµ. Otherwise the DPDA
has no legal move and it rejects without reading the rest of the
input.


LR(k) GRAMMARS
--------------

In an LR(k) grammar, a handle may also depend on symbols that follow
the handle, but only on the first k of these. The acronym LR(k) stands
for: LÌ«eft to right input processing, RÌ«ightmost derivations (or
equivalently, leftmost reductions), and kÌ« symbols of lookahead.

To make this precise, let h be a handle of a valid string v=xhy. Say
that h is forced by lookahead k if h is the unique handle of every
valid string xhyÍ¦ where yÍ¦âˆˆÎ£* and where y and yÍ¦ agree on their first
k symbols. (If either string is shorter than k, the strings must agree
up to the length of the shorter one.)

An LR(k) grammar is a context-free grammar such that the handle of
every valid string is forced by lookahead k.
