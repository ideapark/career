#+TITLE: Effective Go
#+AUTHOR: p@ctriple.cn

* Effective Go :TOC_4_gh:noexport:
- [[#introduction][Introduction]]
  - [[#examples][Examples]]
- [[#formatting][Formatting]]
- [[#commentary][Commentary]]
- [[#names][Names]]
  - [[#package-names][Package names]]
  - [[#getters][Getters]]
  - [[#interface-names][Interface names]]
  - [[#mixedcaps][MixedCaps]]
- [[#semicolons][Semicolons]]
- [[#control-structures][Control structures]]
  - [[#if][If]]
  - [[#redeclaration-and-reassignment][Redeclaration and reassignment]]
  - [[#for][For]]
  - [[#switch][Switch]]
  - [[#type-switch][Type switch]]
- [[#functions][Functions]]
  - [[#multiple-return-values][Multiple return values]]
  - [[#named-result-parameters][Named result parameters]]
  - [[#defer][Defer]]
- [[#data][Data]]
  - [[#allocation-with-new][Allocation with new]]
  - [[#constructors-and-composite-literals][Constructors and composite literals]]
  - [[#allocation-with-make][Allocation with make]]
  - [[#arrays][Arrays]]
  - [[#slices][Slices]]
  - [[#two-dimensional-slices][Two-dimensional slices]]
  - [[#maps][Maps]]
  - [[#printing][Printing]]
  - [[#append][Append]]
- [[#initialization][Initialization]]
  - [[#constants][Constants]]
  - [[#variables][Variables]]
  - [[#the-init-function][The init function]]
- [[#methods][Methods]]
  - [[#pointers-vs-values][Pointers vs. Values]]
- [[#interfaces-and-other-types][Interfaces and other types]]
  - [[#interfaces][Interfaces]]
  - [[#conversions][Conversions]]
  - [[#interface-conversions-and-type-assertions][Interface conversions and type assertions]]
  - [[#generality][Generality]]
  - [[#interfaces-and-methods][Interfaces and methods]]

* Introduction

Go is a new language. Although it borrows ideas from existing languages, it has
unusual properties that make effective Go programs different in character from
programs written in its relatives. A straightforward translation of a C++ or
Java program into Go is unlikely to produce a satisfactory result—Java programs
are written in Java, not Go. On the other hand, thinking about the problem from
a Go perspective could produce a successful but quite different program. In
other words, to write Go well, it's important to understand its properties and
idioms. It's also important to know the established conventions for programming
in Go, such as naming, formatting, program construction, and so on, so that
programs you write will be easy for other Go programmers to understand.

This document gives tips for writing clear, idiomatic Go code. It augments the
language specification, the Tour of Go, and How to Write Go Code, all of which
you should read first.

** Examples

The Go package sources are intended to serve not only as the core library but
also as examples of how to use the language. Moreover, many of the packages
contain working, self-contained executable examples you can run directly from
the golang.org web site, such as this one (if necessary, click on the word
"Example" to open it up). If you have a question about how to approach a problem
or how something might be implemented, the documentation, code and examples in
the library can provide answers, ideas and background.

* Formatting

Formatting issues are the most contentious but the least consequential. People
can adapt to different formatting styles but it's better if they don't have to,
and less time is devoted to the topic if everyone adheres to the same style. The
problem is how to approach this Utopia without a long prescriptive style guide.

With Go we take an unusual approach and let the machine take care of most
formatting issues. The gofmt program (also available as go fmt, which operates
at the package level rather than source file level) reads a Go program and emits
the source in a standard style of indentation and vertical alignment, retaining
and if necessary reformatting comments. If you want to know how to handle some
new layout situation, run gofmt; if the answer doesn't seem right, rearrange
your program (or file a bug about gofmt), don't work around it.

As an example, there's no need to spend time lining up the comments on the
fields of a structure. Gofmt will do that for you. Given the declaration

#+BEGIN_SRC go
type T struct {
    name string // name of the object
    value int // its value
}
#+END_SRC

gofmt will line up the columns:

#+BEGIN_SRC go
type T struct {
    name    string // name of the object
    value   int    // its value
}
#+END_SRC

All Go code in the standard packages has been formatted with gofmt.

Some formatting details remain. Very briefly:

Indentation
    We use tabs for indentation and gofmt emits them by default. Use spaces only
    if you must.
Line length
    Go has no line length limit. Don't worry about overflowing a punched card.
    If a line feels too long, wrap it and indent with an extra tab.
Parentheses
    Go needs fewer parentheses than C and Java: control structures (if, for,
    switch) do not have parentheses in their syntax. Also, the operator
    precedence hierarchy is shorter and clearer, so

#+BEGIN_SRC go
x<<8 + y<<16
#+END_SRC

means what the spacing implies, unlike in the other languages.

* Commentary

Go provides C-style /* */ block comments and C++-style // line comments. Line
comments are the norm; block comments appear mostly as package comments, but are
useful within an expression or to disable large swaths of code.

The program—and web server—godoc processes Go source files to extract
documentation about the contents of the package. Comments that appear before
top-level declarations, with no intervening newlines, are extracted along with
the declaration to serve as explanatory text for the item. The nature and style
of these comments determines the quality of the documentation godoc produces.

Every package should have a package comment, a block comment preceding the
package clause. For multi-file packages, the package comment only needs to be
present in one file, and any one will do. The package comment should introduce
the package and provide information relevant to the package as a whole. It will
appear first on the godoc page and should set up the detailed documentation that
follows.

#+BEGIN_SRC go
/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
#+END_SRC

If the package is simple, the package comment can be brief.

#+BEGIN_SRC go
// Package path implements utility routines for
// manipulating slash-separated filename paths.
#+END_SRC

Comments do not need extra formatting such as banners of stars. The generated
output may not even be presented in a fixed-width font, so don't depend on
spacing for alignment—godoc, like gofmt, takes care of that. The comments are
uninterpreted plain text, so HTML and other annotations such as _this_ will
reproduce verbatim and should not be used. One adjustment godoc does do is to
display indented text in a fixed-width font, suitable for program snippets. The
package comment for the fmt package uses this to good effect.

Depending on the context, godoc might not even reformat comments, so make sure
they look good straight up: use correct spelling, punctuation, and sentence
structure, fold long lines, and so on.

Inside a package, any comment immediately preceding a top-level declaration
serves as a doc comment for that declaration. Every exported (capitalized) name
in a program should have a doc comment.

Doc comments work best as complete sentences, which allow a wide variety of
automated presentations. The first sentence should be a one-sentence summary
that starts with the name being declared.

#+BEGIN_SRC go
// Compile parses a regular expression and returns, if successful,
// a Regexp that can be used to match against text.
func Compile(str string) (*Regexp, error) {
#+END_SRC

If every doc comment begins with the name of the item it describes, the output
of godoc can usefully be run through grep. Imagine you couldn't remember the
name "Compile" but were looking for the parsing function for regular
expressions, so you ran the command,

#+BEGIN_SRC shell
$ godoc regexp | grep -i parse
#+END_SRC

If all the doc comments in the package began, "This function...", grep wouldn't
help you remember the name. But because the package starts each doc comment with
the name, you'd see something like this, which recalls the word you're looking
for.

#+BEGIN_SRC shell
$ godoc regexp | grep parse
    Compile parses a regular expression and returns, if successful, a Regexp
    parsed. It simplifies safe initialization of global variables holding
    cannot be parsed. It simplifies safe initialization of global variables
$
#+END_SRC

Go's declaration syntax allows grouping of declarations. A single doc comment
can introduce a group of related constants or variables. Since the whole
declaration is presented, such a comment can often be perfunctory.

#+BEGIN_SRC go
// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
#+END_SRC

Grouping can also indicate relationships between items, such as the fact that a
set of variables is protected by a mutex.

#+BEGIN_SRC go
var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
#+END_SRC

* Names

Names are as important in Go as in any other language. They even have semantic
effect: the visibility of a name outside a package is determined by whether its
first character is upper case. It's therefore worth spending a little time
talking about naming conventions in Go programs.

** Package names

When a package is imported, the package name becomes an accessor for the
contents. After

#+BEGIN_SRC go
import "bytes"
#+END_SRC

the importing package can talk about bytes.Buffer. It's helpful if everyone
using the package can use the same name to refer to its contents, which implies
that the package name should be good: short, concise, evocative. By convention,
packages are given lower case, single-word names; there should be no need for
underscores or mixedCaps. Err on the side of brevity, since everyone using your
package will be typing that name. And don't worry about collisions a priori. The
package name is only the default name for imports; it need not be unique across
all source code, and in the rare case of a collision the importing package can
choose a different name to use locally. In any case, confusion is rare because
the file name in the import determines just which package is being used.

Another convention is that the package name is the base name of its source
directory; the package in src/encoding/base64 is imported as "encoding/base64"
but has name base64, not encoding_base64 and not encodingBase64.

The importer of a package will use the name to refer to its contents, so
exported names in the package can use that fact to avoid stutter. (Don't use the
import . notation, which can simplify tests that must run outside the package
they are testing, but should otherwise be avoided.) For instance, the buffered
reader type in the bufio package is called Reader, not BufReader, because users
see it as bufio.Reader, which is a clear, concise name. Moreover, because
imported entities are always addressed with their package name, bufio.Reader
does not conflict with io.Reader. Similarly, the function to make new instances
of ring.Ring—which is the definition of a constructor in Go—would normally be
called NewRing, but since Ring is the only type exported by the package, and
since the package is called ring, it's called just New, which clients of the
package see as ring.New. Use the package structure to help you choose good
names.

Another short example is once.Do; once.Do(setup) reads well and would not be
improved by writing once.DoOrWaitUntilDone(setup). Long names don't
automatically make things more readable. A helpful doc comment can often be more
valuable than an extra long name.

** Getters

Go doesn't provide automatic support for getters and setters. There's nothing
wrong with providing getters and setters yourself, and it's often appropriate to
do so, but it's neither idiomatic nor necessary to put Get into the getter's
name. If you have a field called owner (lower case, unexported), the getter
method should be called Owner (upper case, exported), not GetOwner. The use of
upper-case names for export provides the hook to discriminate the field from the
method. A setter function, if needed, will likely be called SetOwner. Both names
read well in practice:

#+BEGIN_SRC go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
#+END_SRC

** Interface names

By convention, one-method interfaces are named by the method name plus an -er
suffix or similar modification to construct an agent noun: Reader, Writer,
Formatter, CloseNotifier etc.

There are a number of such names and it's productive to honor them and the
function names they capture. Read, Write, Close, Flush, String and so on have
canonical signatures and meanings. To avoid confusion, don't give your method
one of those names unless it has the same signature and meaning. Conversely, if
your type implements a method with the same meaning as a method on a well-known
type, give it the same name and signature; call your string-converter method
String not ToString.

** MixedCaps

Finally, the convention in Go is to use MixedCaps or mixedCaps rather than
underscores to write multiword names.

* Semicolons

Like C, Go's formal grammar uses semicolons to terminate statements, but unlike
in C, those semicolons do not appear in the source. Instead the lexer uses a
simple rule to insert semicolons automatically as it scans, so the input text is
mostly free of them.

The rule is this. If the last token before a newline is an identifier (which
includes words like int and float64), a basic literal such as a number or string
constant, or one of the tokens

#+BEGIN_SRC go
break continue fallthrough return ++ -- ) }
#+END_SRC

the lexer always inserts a semicolon after the token. This could be summarized
as, “if the newline comes after a token that could end a statement, insert a
semicolon”.

A semicolon can also be omitted immediately before a closing brace, so a
statement such as

#+BEGIN_SRC go
go func() { for { dst <- <-src } }()
#+END_SRC

needs no semicolons. Idiomatic Go programs have semicolons only in places such
as for loop clauses, to separate the initializer, condition, and continuation
elements. They are also necessary to separate multiple statements on a line,
should you write code that way.

One consequence of the semicolon insertion rules is that you cannot put the
opening brace of a control structure (if, for, switch, or select) on the next
line. If you do, a semicolon will be inserted before the brace, which could
cause unwanted effects. Write them like this

#+BEGIN_SRC go
if i < f() {
    g()
}
#+END_SRC

not like this

#+BEGIN_SRC go
if i < f()  // wrong!
{           // wrong!
    g()
}
#+END_SRC

* Control structures

The control structures of Go are related to those of C but differ in important
ways. There is no do or while loop, only a slightly generalized for; switch is
more flexible; if and switch accept an optional initialization statement like
that of for; break and continue statements take an optional label to identify
what to break or continue; and there are new control structures including a type
switch and a multiway communications multiplexer, select. The syntax is also
slightly different: there are no parentheses and the bodies must always be
brace-delimited.

** If

In Go a simple if looks like this:

#+BEGIN_SRC go
if x > 0 {
    return y
}
#+END_SRC

Mandatory braces encourage writing simple if statements on multiple lines. It's
good style to do so anyway, especially when the body contains a control
statement such as a return or break.

Since if and switch accept an initialization statement, it's common to see one
used to set up a local variable.

#+BEGIN_SRC go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
#+END_SRC

In the Go libraries, you'll find that when an if statement doesn't flow into the
next statement—that is, the body ends in break, continue, goto, or return—the
unnecessary else is omitted.

#+BEGIN_SRC go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
#+END_SRC

This is an example of a common situation where code must guard against a
sequence of error conditions. The code reads well if the successful flow of
control runs down the page, eliminating error cases as they arise. Since error
cases tend to end in return statements, the resulting code needs no else
statements.

#+BEGIN_SRC go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
#+END_SRC

** Redeclaration and reassignment

An aside: The last example in the previous section demonstrates a detail of how
the := short declaration form works. The declaration that calls os.Open reads,

#+BEGIN_SRC go
f, err := os.Open(name)
#+END_SRC

This statement declares two variables, f and err. A few lines later, the call to
f.Stat reads,

#+BEGIN_SRC go
d, err := f.Stat()
#+END_SRC

which looks as if it declares d and err. Notice, though, that err appears in
both statements. This duplication is legal: err is declared by the first
statement, but only re-assigned in the second. This means that the call to
f.Stat uses the existing err variable declared above, and just gives it a new
value.

In a := declaration a variable v may appear even if it has already been
declared, provided:

    1) this declaration is in the same scope as the existing declaration of v
       (if v is already declared in an outer scope, the declaration will create
       a new variable §),
    2) the corresponding value in the initialization is assignable to v, and
    3) there is at least one other variable in the declaration that is being
       declared anew.

This unusual property is pure pragmatism, making it easy to use a single err
value, for example, in a long if-else chain. You'll see it used often.

§ It's worth noting here that in Go the scope of function parameters and return
values is the same as the function body, even though they appear lexically
outside the braces that enclose the body.

** For

The Go for loop is similar to—but not the same as—C's. It unifies for and while
and there is no do-while. There are three forms, only one of which has
semicolons.

#+BEGIN_SRC go
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
#+END_SRC

Short declarations make it easy to declare the index variable right in the loop.

#+BEGIN_SRC go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
#+END_SRC

If you're looping over an array, slice, string, or map, or reading from a
channel, a range clause can manage the loop.

#+BEGIN_SRC go
for key, value := range oldMap {
    newMap[key] = value
}
#+END_SRC

If you only need the first item in the range (the key or index), drop the
second:

#+BEGIN_SRC go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
#+END_SRC

If you only need the second item in the range (the value), use the blank
identifier, an underscore, to discard the first:

#+BEGIN_SRC go
sum := 0
for _, value := range array {
    sum += value
}
#+END_SRC

The blank identifier has many uses, as described in a later section.

For strings, the range does more work for you, breaking out individual Unicode
code points by parsing the UTF-8. Erroneous encodings consume one byte and
produce the replacement rune U+FFFD. (The name (with associated builtin type)
rune is Go terminology for a single Unicode code point. See the language
specification for details.) The loop

#+BEGIN_SRC go
for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
#+END_SRC

prints

#+BEGIN_SRC go
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
#+END_SRC

Finally, Go has no comma operator and ++ and -- are statements not expressions.
Thus if you want to run multiple variables in a for you should use parallel
assignment (although that precludes ++ and --).

#+BEGIN_SRC go
// Reverse a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
#+END_SRC

** Switch

Go's switch is more general than C's. The expressions need not be constants or
even integers, the cases are evaluated top to bottom until a match is found, and
if the switch has no expression it switches on true. It's therefore possible—and
idiomatic—to write an if-else-if-else chain as a switch.

#+BEGIN_SRC go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
#+END_SRC

There is no automatic fall through, but cases can be presented in
comma-separated lists.

#+BEGIN_SRC go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
#+END_SRC

Although they are not nearly as common in Go as some other C-like languages,
break statements can be used to terminate a switch early. Sometimes, though,
it's necessary to break out of a surrounding loop, not the switch, and in Go
that can be accomplished by putting a label on the loop and "breaking" to that
label. This example shows both uses.

#+BEGIN_SRC go
Loop:
	for n := 0; n < len(src); n += size {
		switch {
		case src[n] < sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] < sizeTwo:
			if n+1 >= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]<<shift)
		}
	}
#+END_SRC

Of course, the continue statement also accepts an optional label but it applies
only to loops.

To close this section, here's a comparison routine for byte slices that uses two
switch statements:

#+BEGIN_SRC go
// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
#+END_SRC

** Type switch

A switch can also be used to discover the dynamic type of an interface variable.
Such a type switch uses the syntax of a type assertion with the keyword type
inside the parentheses. If the switch declares a variable in the expression, the
variable will have the corresponding type in each clause. It's also idiomatic to
reuse the name in such cases, in effect declaring a new variable with the same
name but a different type in each case.

#+BEGIN_SRC go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T prints whatever type t has
case bool:
    fmt.Printf("boolean %t\n", t)             // t has type bool
case int:
    fmt.Printf("integer %d\n", t)             // t has type int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t has type *int
}
#+END_SRC

* Functions

** Multiple return values

One of Go's unusual features is that functions and methods can return multiple
values. This form can be used to improve on a couple of clumsy idioms in C
programs: in-band error returns such as -1 for EOF and modifying an argument
passed by address.

In C, a write error is signaled by a negative count with the error code secreted
away in a volatile location. In Go, Write can return a count and an error:
“Yes, you wrote some bytes but not all of them because you filled the device”.
The signature of the Write method on files from package os is:

#+BEGIN_SRC go
func (file *File) Write(b []byte) (n int, err error)
#+END_SRC

and as the documentation says, it returns the number of bytes written and a
non-nil error when n != len(b). This is a common style; see the section on error
handling for more examples.

A similar approach obviates the need to pass a pointer to a return value to
simulate a reference parameter. Here's a simple-minded function to grab a number
from a position in a byte slice, returning the number and the next position.

#+BEGIN_SRC go
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
#+END_SRC

You could use it to scan the numbers in an input slice b like this:

#+BEGIN_SRC go
    for i := 0; i < len(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
#+END_SRC

** Named result parameters

The return or result "parameters" of a Go function can be given names and used
as regular variables, just like the incoming parameters. When named, they are
initialized to the zero values for their types when the function begins; if the
function executes a return statement with no arguments, the current values of
the result parameters are used as the returned values.

The names are not mandatory but they can make code shorter and clearer: they're
documentation. If we name the results of nextInt it becomes obvious which
returned int is which.

#+BEGIN_SRC go
func nextInt(b []byte, pos int) (value, nextPos int) {
#+END_SRC

Because named results are initialized and tied to an unadorned return, they can
simplify as well as clarify. Here's a version of io.ReadFull that uses them
well:

#+BEGIN_SRC go
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
#+END_SRC

** Defer

Go's defer statement schedules a function call (the deferred function) to be run
immediately before the function executing the defer returns. It's an unusual but
effective way to deal with situations such as resources that must be released
regardless of which path a function takes to return. The canonical examples are
unlocking a mutex or closing a file.

#+BEGIN_SRC go
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
#+END_SRC

Deferring a call to a function such as Close has two advantages. First, it
guarantees that you will never forget to close the file, a mistake that's easy
to make if you later edit the function to add a new return path. Second, it
means that the close sits near the open, which is much clearer than placing it
at the end of the function.

The arguments to the deferred function (which include the receiver if the
function is a method) are evaluated when the defer executes, not when the call
executes. Besides avoiding worries about variables changing values as the
function executes, this means that a single deferred call site can defer
multiple function executions. Here's a silly example.

#+BEGIN_SRC go
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
#+END_SRC

Deferred functions are executed in LIFO order, so this code will cause 4 3 2 1 0
to be printed when the function returns. A more plausible example is a simple
way to trace function execution through the program. We could write a couple of
simple tracing routines like this:

#+BEGIN_SRC go
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
#+END_SRC

We can do better by exploiting the fact that arguments to deferred functions are
evaluated when the defer executes. The tracing routine can set up the argument
to the untracing routine. This example:

#+BEGIN_SRC go
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
#+END_SRC

prints

#+BEGIN_SRC shell
entering: b
in b
entering: a
in a
leaving: a
leaving: b
#+END_SRC

For programmers accustomed to block-level resource management from other
languages, defer may seem peculiar, but its most interesting and powerful
applications come precisely from the fact that it's not block-based but
function-based. In the section on panic and recover we'll see another example of
its possibilities.

* Data

** Allocation with new

Go has two allocation primitives, the built-in functions new and make. They do
different things and apply to different types, which can be confusing, but the
rules are simple. Let's talk about new first. It's a built-in function that
allocates memory, but unlike its namesakes in some other languages it does not
initialize the memory, it only zeros it. That is, new(T) allocates zeroed
storage for a new item of type T and returns its address, a value of type *T. In
Go terminology, it returns a pointer to a newly allocated zero value of type T.

Since the memory returned by new is zeroed, it's helpful to arrange when
designing your data structures that the zero value of each type can be used
without further initialization. This means a user of the data structure can
create one with new and get right to work. For example, the documentation for
bytes.Buffer states that "the zero value for Buffer is an empty buffer ready to
use." Similarly, sync.Mutex does not have an explicit constructor or Init
method. Instead, the zero value for a sync.Mutex is defined to be an unlocked
mutex.

The zero-value-is-useful property works transitively. Consider this type
declaration.

#+BEGIN_SRC go
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
#+END_SRC

Values of type SyncedBuffer are also ready to use immediately upon allocation or
just declaration. In the next snippet, both p and v will work correctly without
further arrangement.

#+BEGIN_SRC go
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
#+END_SRC

** Constructors and composite literals

Sometimes the zero value isn't good enough and an initializing constructor is
necessary, as in this example derived from package os.

#+BEGIN_SRC go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
#+END_SRC

There's a lot of boiler plate in there. We can simplify it using a composite
literal, which is an expression that creates a new instance each time it is
evaluated.

#+BEGIN_SRC go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
#+END_SRC

Note that, unlike in C, it's perfectly OK to return the address of a local
variable; the storage associated with the variable survives after the function
returns. In fact, taking the address of a composite literal allocates a fresh
instance each time it is evaluated, so we can combine these last two lines.

#+BEGIN_SRC go
return &File{fd, name, nil, 0}
#+END_SRC

The fields of a composite literal are laid out in order and must all be present.
However, by labeling the elements explicitly as field:value pairs, the
initializers can appear in any order, with the missing ones left as their
respective zero values. Thus we could say

#+BEGIN_SRC go
return &File{fd: fd, name: name}
#+END_SRC

As a limiting case, if a composite literal contains no fields at all, it creates
a zero value for the type. The expressions new(File) and &File{} are equivalent.

Composite literals can also be created for arrays, slices, and maps, with the
field labels being indices or map keys as appropriate. In these examples, the
initializations work regardless of the values of Enone, Eio, and Einval, as long
as they are distinct.

#+BEGIN_SRC go
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
#+END_SRC

** Allocation with make

Back to allocation. The built-in function make(T, args) serves a purpose
different from new(T). It creates slices, maps, and channels only, and it
returns an initialized (not zeroed) value of type T (not *T). The reason for the
distinction is that these three types represent, under the covers, references to
data structures that must be initialized before use. A slice, for example, is a
three-item descriptor containing a pointer to the data (inside an array), the
length, and the capacity, and until those items are initialized, the slice is
nil. For slices, maps, and channels, make initializes the internal data
structure and prepares the value for use. For instance,

#+BEGIN_SRC
make([]int, 10, 100)
#+END_SRC

allocates an array of 100 ints and then creates a slice structure with length 10
and a capacity of 100 pointing at the first 10 elements of the array. (When
making a slice, the capacity can be omitted; see the section on slices for more
information.) In contrast, new([]int) returns a pointer to a newly allocated,
zeroed slice structure, that is, a pointer to a nil slice value.

These examples illustrate the difference between new and make.

#+BEGIN_SRC go
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
#+END_SRC

Remember that make applies only to maps, slices and channels and does not return
a pointer. To obtain an explicit pointer allocate with new or take the address
of a variable explicitly.

** Arrays

Arrays are useful when planning the detailed layout of memory and sometimes can
help avoid allocation, but primarily they are a building block for slices, the
subject of the next section. To lay the foundation for that topic, here are a
few words about arrays.

There are major differences between the ways arrays work in Go and C. In Go,

    1) Arrays are values. Assigning one array to another copies all the
       elements.
    2) In particular, if you pass an array to a function, it will receive a copy
       of the array, not a pointer to it.
    3) The size of an array is part of its type. The types [10]int and [20]int
       are distinct.

The value property can be useful but also expensive; if you want C-like behavior
and efficiency, you can pass a pointer to the array.

#+BEGIN_SRC go
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&array)  // Note the explicit address-of operator
#+END_SRC

But even this style isn't idiomatic Go. Use slices instead.

** Slices

Slices wrap arrays to give a more general, powerful, and convenient interface to
sequences of data. Except for items with explicit dimension such as
transformation matrices, most array programming in Go is done with slices rather
than simple arrays.

Slices hold references to an underlying array, and if you assign one slice to
another, both refer to the same array. If a function takes a slice argument,
changes it makes to the elements of the slice will be visible to the caller,
analogous to passing a pointer to the underlying array. A Read function can
therefore accept a slice argument rather than a pointer and a count; the length
within the slice sets an upper limit of how much data to read. Here is the
signature of the Read method of the File type in package os:

#+BEGIN_SRC go
func (f *File) Read(buf []byte) (n int, err error)
#+END_SRC

The method returns the number of bytes read and an error value, if any. To read
into the first 32 bytes of a larger buffer buf, slice (here used as a verb) the
buffer.

#+BEGIN_SRC go
    n, err := f.Read(buf[0:32])
#+END_SRC

Such slicing is common and efficient. In fact, leaving efficiency aside for the
moment, the following snippet would also read the first 32 bytes of the buffer.

#+BEGIN_SRC go
    var n int
    var err error
    for i := 0; i < 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
#+END_SRC

The length of a slice may be changed as long as it still fits within the limits
of the underlying array; just assign it to a slice of itself. The capacity of a
slice, accessible by the built-in function cap, reports the maximum length the
slice may assume. Here is a function to append data to a slice. If the data
exceeds the capacity, the slice is reallocated. The resulting slice is returned.
The function uses the fact that len and cap are legal when applied to the nil
slice, and return 0.

#+BEGIN_SRC go
func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) > cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
#+END_SRC

We must return the slice afterwards because, although Append can modify the
elements of slice, the slice itself (the run-time data structure holding the
pointer, length, and capacity) is passed by value.

The idea of appending to a slice is so useful it's captured by the append
built-in function. To understand that function's design, though, we need a
little more information, so we'll return to it later.

** Two-dimensional slices

Go's arrays and slices are one-dimensional. To create the equivalent of a 2D
array or slice, it is necessary to define an array-of-arrays or slice-of-slices,
like this:

#+BEGIN_SRC go
type Transform [3][3]float64  // A 3x3 array, really an array of arrays.
type LinesOfText [][]byte     // A slice of byte slices.
#+END_SRC

Because slices are variable-length, it is possible to have each inner slice be a
different length. That can be a common situation, as in our LinesOfText example:
each line has an independent length.

#+BEGIN_SRC go
text := LinesOfText{
	[]byte("Now is the time"),
	[]byte("for all good gophers"),
	[]byte("to bring some fun to the party."),
}
#+END_SRC

Sometimes it's necessary to allocate a 2D slice, a situation that can arise when
processing scan lines of pixels, for instance. There are two ways to achieve
this. One is to allocate each slice independently; the other is to allocate a
single array and point the individual slices into it. Which to use depends on
your application. If the slices might grow or shrink, they should be allocated
independently to avoid overwriting the next line; if not, it can be more
efficient to construct the object with a single allocation. For reference, here
are sketches of the two methods. First, a line at a time:

#+BEGIN_SRC go
// Allocate the top-level slice.
picture := make([][]uint8, YSize) // One row per unit of y.
// Loop over the rows, allocating the slice for each row.
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
#+END_SRC

And now as one allocation, sliced into lines:

#+BEGIN_SRC go
// Allocate the top-level slice, the same as before.
picture := make([][]uint8, YSize) // One row per unit of y.
// Allocate one large slice to hold all the pixels.
pixels := make([]uint8, XSize*YSize) // Has type []uint8 even though picture is [][]uint8.
// Loop over the rows, slicing each row from the front of the remaining pixels slice.
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
#+END_SRC

** Maps

Maps are a convenient and powerful built-in data structure that associate values
of one type (the key) with values of another type (the element or value) The key
can be of any type for which the equality operator is defined, such as integers,
floating point and complex numbers, strings, pointers, interfaces (as long as
the dynamic type supports equality), structs and arrays. Slices cannot be used
as map keys, because equality is not defined on them. Like slices, maps hold
references to an underlying data structure. If you pass a map to a function that
changes the contents of the map, the changes will be visible in the caller.

Maps can be constructed using the usual composite literal syntax with
colon-separated key-value pairs, so it's easy to build them during
initialization.

#+BEGIN_SRC go
var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
#+END_SRC

Assigning and fetching map values looks syntactically just like doing the same
for arrays and slices except that the index doesn't need to be an integer.

#+BEGIN_SRC go
offset := timeZone["EST"]
#+END_SRC

An attempt to fetch a map value with a key that is not present in the map will
return the zero value for the type of the entries in the map. For instance, if
the map contains integers, looking up a non-existent key will return 0. A set
can be implemented as a map with value type bool. Set the map entry to true to
put the value in the set, and then test it by simple indexing.

#+BEGIN_SRC go
attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // will be false if person is not in the map
    fmt.Println(person, "was at the meeting")
}
#+END_SRC

Sometimes you need to distinguish a missing entry from a zero value. Is there an
entry for "UTC" or is that 0 because it's not in the map at all? You can
discriminate with a form of multiple assignment.

#+BEGIN_SRC go
var seconds int
var ok bool
seconds, ok = timeZone[tz]
#+END_SRC

For obvious reasons this is called the “comma ok” idiom. In this example, if
tz is present, seconds will be set appropriately and ok will be true; if not,
seconds will be set to zero and ok will be false. Here's a function that puts it
together with a nice error report:

#+BEGIN_SRC go
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
#+END_SRC

To test for presence in the map without worrying about the actual value, you can
use the blank identifier (_) in place of the usual variable for the value.

#+BEGIN_SRC go
_, present := timeZone[tz]
#+END_SRC

To delete a map entry, use the delete built-in function, whose arguments are the
map and the key to be deleted. It's safe to do this even if the key is already
absent from the map.

#+BEGIN_SRC go
delete(timeZone, "PDT")  // Now on Standard Time
#+END_SRC

** Printing

Formatted printing in Go uses a style similar to C's printf family but is richer
and more general. The functions live in the fmt package and have capitalized
names: fmt.Printf, fmt.Fprintf, fmt.Sprintf and so on. The string functions
(Sprintf etc.) return a string rather than filling in a provided buffer.

You don't need to provide a format string. For each of Printf, Fprintf and
Sprintf there is another pair of functions, for instance Print and Println.
These functions do not take a format string but instead generate a default
format for each argument. The Println versions also insert a blank between
arguments and append a newline to the output while the Print versions add blanks
only if the operand on neither side is a string. In this example each line
produces the same output.

#+BEGIN_SRC go
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
#+END_SRC

The formatted print functions fmt.Fprint and friends take as a first argument
any object that implements the io.Writer interface; the variables os.Stdout and
os.Stderr are familiar instances.

Here things start to diverge from C. First, the numeric formats such as %d do
not take flags for signedness or size; instead, the printing routines use the
type of the argument to decide these properties.

#+BEGIN_SRC go
var x uint64 = 1<<64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
#+END_SRC

prints

#+BEGIN_SRC go
18446744073709551615 ffffffffffffffff; -1 -1
#+END_SRC

If you just want the default conversion, such as decimal for integers, you can
use the catchall format %v (for “value”); the result is exactly what Print and
Println would produce. Moreover, that format can print any value, even arrays,
slices, structs, and maps. Here is a print statement for the time zone map
defined in the previous section.

#+BEGIN_SRC go
fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
#+END_SRC

which gives output

#+BEGIN_SRC go
map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
#+END_SRC

For maps the keys may be output in any order, of course. When printing a struct,
the modified format %+v annotates the fields of the structure with their names,
and for any value the alternate format %#v prints the value in full Go syntax.

#+BEGIN_SRC go
type T struct {
    a int
    b float64
    c string
}
t := &T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
#+END_SRC

prints

#+BEGIN_SRC go
&{7 -2.35 abc   def}
&{a:7 b:-2.35 c:abc     def}
&main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
#+END_SRC

(Note the ampersands.) That quoted string format is also available through %q
when applied to a value of type string or []byte. The alternate format %#q will
use backquotes instead if possible. (The %q format also applies to integers and
runes, producing a single-quoted rune constant.) Also, %x works on strings, byte
arrays and byte slices as well as on integers, generating a long hexadecimal
string, and with a space in the format (% x) it puts spaces between the bytes.

Another handy format is %T, which prints the type of a value.

#+BEGIN_SRC go
fmt.Printf("%T\n", timeZone)
#+END_SRC

prints

#+BEGIN_SRC go
map[string] int
#+END_SRC

If you want to control the default format for a custom type, all that's required
is to define a method with the signature String() string on the type. For our
simple type T, that might look like this.

#+BEGIN_SRC go
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
#+END_SRC

to print in the format

#+BEGIN_SRC go
7/-2.35/"abc\tdef"
#+END_SRC

(If you need to print values of type T as well as pointers to T, the receiver
for String must be of value type; this example used a pointer because that's
more efficient and idiomatic for struct types. See the section below on pointers
vs. value receivers for more information.)

Our String method is able to call Sprintf because the print routines are fully
reentrant and can be wrapped this way. There is one important detail to
understand about this approach, however: don't construct a String method by
calling Sprintf in a way that will recur into your String method indefinitely.
This can happen if the Sprintf call attempts to print the receiver directly as a
string, which in turn will invoke the method again. It's a common and easy
mistake to make, as this example shows.

#+BEGIN_SRC go
type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Error: will recur forever.
}
#+END_SRC

It's also easy to fix: convert the argument to the basic string type, which does
not have the method.

#+BEGIN_SRC go
type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK: note conversion.
}
#+END_SRC

In the initialization section we'll see another technique that avoids this
recursion.

Another printing technique is to pass a print routine's arguments directly to
another such routine. The signature of Printf uses the type ...interface{} for
its final argument to specify that an arbitrary number of parameters (of
arbitrary type) can appear after the format.

#+BEGIN_SRC go
func Printf(format string, v ...interface{}) (n int, err error) {
#+END_SRC

Within the function Printf, v acts like a variable of type []interface{} but if
it is passed to another variadic function, it acts like a regular list of
arguments. Here is the implementation of the function log.Println we used above.
It passes its arguments directly to fmt.Sprintln for the actual formatting.

#+BEGIN_SRC go
// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
#+END_SRC

We write ... after v in the nested call to Sprintln to tell the compiler to
treat v as a list of arguments; otherwise it would just pass v as a single slice
argument.

There's even more to printing than we've covered here. See the godoc
documentation for package fmt for the details.

By the way, a ... parameter can be of a specific type, for instance ...int for a
min function that chooses the least of a list of integers:

#+BEGIN_SRC go
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // largest int
    for _, i := range a {
        if i < min {
            min = i
        }
    }
    return min
}
#+END_SRC

** Append

Now we have the missing piece we needed to explain the design of the append
built-in function. The signature of append is different from our custom Append
function above. Schematically, it's like this:

#+BEGIN_SRC go
func append(slice []T, elements ...T) []T
#+END_SRC

where T is a placeholder for any given type. You can't actually write a function
in Go where the type T is determined by the caller. That's why append is built
in: it needs support from the compiler.

What append does is append the elements to the end of the slice and return the
result. The result needs to be returned because, as with our hand-written
Append, the underlying array may change. This simple example

#+BEGIN_SRC go
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
#+END_SRC

prints [1 2 3 4 5 6]. So append works a little like Printf, collecting an
arbitrary number of arguments.

But what if we wanted to do what our Append does and append a slice to a slice?
Easy: use ... at the call site, just as we did in the call to Output above. This
snippet produces identical output to the one above.

#+BEGIN_SRC go
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
#+END_SRC

Without that ..., it wouldn't compile because the types would be wrong; y is not
of type int.

* Initialization

Although it doesn't look superficially very different from initialization in C
or C++, initialization in Go is more powerful. Complex structures can be built
during initialization and the ordering issues among initialized objects, even
among different packages, are handled correctly.

** Constants

Constants in Go are just that—constant. They are created at compile time, even
when defined as locals in functions, and can only be numbers, characters
(runes), strings or booleans. Because of the compile-time restriction, the
expressions that define them must be constant expressions, evaluatable by the
compiler. For instance, 1<<3 is a constant expression, while math.Sin(math.Pi/4)
is not because the function call to math.Sin needs to happen at run time.

In Go, enumerated constants are created using the iota enumerator. Since iota
can be part of an expression and expressions can be implicitly repeated, it is
easy to build intricate sets of values.

#+BEGIN_SRC go
type ByteSize float64

const (
    _           = iota // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)
#+END_SRC

The ability to attach a method such as String to any user-defined type makes it
possible for arbitrary values to format themselves automatically for printing.
Although you'll see it most often applied to structs, this technique is also
useful for scalar types such as floating-point types like ByteSize.

#+BEGIN_SRC go
func (b ByteSize) String() string {
    switch {
    case b >= YB:
        return fmt.Sprintf("%.2fYB", b/YB)
    case b >= ZB:
        return fmt.Sprintf("%.2fZB", b/ZB)
    case b >= EB:
        return fmt.Sprintf("%.2fEB", b/EB)
    case b >= PB:
        return fmt.Sprintf("%.2fPB", b/PB)
    case b >= TB:
        return fmt.Sprintf("%.2fTB", b/TB)
    case b >= GB:
        return fmt.Sprintf("%.2fGB", b/GB)
    case b >= MB:
        return fmt.Sprintf("%.2fMB", b/MB)
    case b >= KB:
        return fmt.Sprintf("%.2fKB", b/KB)
    }
    return fmt.Sprintf("%.2fB", b)
}
#+END_SRC

The expression YB prints as 1.00YB, while ByteSize(1e13) prints as 9.09TB.

The use here of Sprintf to implement ByteSize's String method is safe (avoids
recurring indefinitely) not because of a conversion but because it calls Sprintf
with %f, which is not a string format: Sprintf will only call the String method
when it wants a string, and %f wants a floating-point value.

** Variables

Variables can be initialized just like constants but the initializer can be a
general expression computed at run time.

#+BEGIN_SRC go
var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
#+END_SRC

** The init function

Finally, each source file can define its own niladic init function to set up
whatever state is required. (Actually each file can have multiple init
functions.) And finally means finally: init is called after all the variable
declarations in the package have evaluated their initializers, and those are
evaluated only after all the imported packages have been initialized.

Besides initializations that cannot be expressed as declarations, a common use
of init functions is to verify or repair correctness of the program state before
real execution begins.

#+BEGIN_SRC go
func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath may be overridden by --gopath flag on command line.
    flag.StringVar(&gopath, "gopath", gopath, "override default GOPATH")
}
#+END_SRC

* Methods

** Pointers vs. Values

As we saw with ByteSize, methods can be defined for any named type (except a
pointer or an interface); the receiver does not have to be a struct.

In the discussion of slices above, we wrote an Append function. We can define it
as a method on slices instead. To do this, we first declare a named type to
which we can bind the method, and then make the receiver for the method a value
of that type.

#+BEGIN_SRC go
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Body exactly the same as the Append function defined above.
}
#+END_SRC

This still requires the method to return the updated slice. We can eliminate
that clumsiness by redefining the method to take a pointer to a ByteSlice as its
receiver, so the method can overwrite the caller's slice.

#+BEGIN_SRC go
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Body as above, without the return.
    *p = slice
}
#+END_SRC

In fact, we can do even better. If we modify our function so it looks like a
standard Write method, like this,

#+BEGIN_SRC go
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Again as above.
    *p = slice
    return len(data), nil
}
#+END_SRC

then the type *ByteSlice satisfies the standard interface io.Writer, which is
handy. For instance, we can print into one.

#+BEGIN_SRC go
    var b ByteSlice
    fmt.Fprintf(&b, "This hour has %d days\n", 7)
#+END_SRC

We pass the address of a ByteSlice because only *ByteSlice satisfies io.Writer.
The rule about pointers vs. values for receivers is that value methods can be
invoked on pointers and values, but pointer methods can only be invoked on
pointers.

This rule arises because pointer methods can modify the receiver; invoking them
on a value would cause the method to receive a copy of the value, so any
modifications would be discarded. The language therefore disallows this mistake.
There is a handy exception, though. When the value is addressable, the language
takes care of the common case of invoking a pointer method on a value by
inserting the address operator automatically. In our example, the variable b is
addressable, so we can call its Write method with just b.Write. The compiler
will rewrite that to (&b).Write for us.

By the way, the idea of using Write on a slice of bytes is central to the
implementation of bytes.Buffer.

* Interfaces and other types

** Interfaces

Interfaces in Go provide a way to specify the behavior of an object: if
something can do this, then it can be used here. We've seen a couple of simple
examples already; custom printers can be implemented by a String method while
Fprintf can generate output to anything with a Write method. Interfaces with
only one or two methods are common in Go code, and are usually given a name
derived from the method, such as io.Writer for something that implements Write.

A type can implement multiple interfaces. For instance, a collection can be
sorted by the routines in package sort if it implements sort.Interface, which
contains Len(), Less(i, j int) bool, and Swap(i, j int), and it could also have
a custom formatter. In this contrived example Sequence satisfies both.

#+BEGIN_SRC go
type Sequence []int

// Methods required by sort.Interface.
func (s Sequence) Len() int {
    return len(s)
}
func (s Sequence) Less(i, j int) bool {
    return s[i] < s[j]
}
func (s Sequence) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

// Method for printing - sorts the elements before printing.
func (s Sequence) String() string {
    sort.Sort(s)
    str := "["
    for i, elem := range s {
        if i > 0 {
            str += " "
        }
        str += fmt.Sprint(elem)
    }
    return str + "]"
}
#+END_SRC

** Conversions

The String method of Sequence is recreating the work that Sprint already does
for slices. We can share the effort if we convert the Sequence to a plain []int
before calling Sprint.

#+BEGIN_SRC go
func (s Sequence) String() string {
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
#+END_SRC

This method is another example of the conversion technique for calling Sprintf
safely from a String method. Because the two types (Sequence and []int) are the
same if we ignore the type name, it's legal to convert between them. The
conversion doesn't create a new value, it just temporarily acts as though the
existing value has a new type. (There are other legal conversions, such as from
integer to floating point, that do create a new value.)

It's an idiom in Go programs to convert the type of an expression to access a
different set of methods. As an example, we could use the existing type
sort.IntSlice to reduce the entire example to this:

#+BEGIN_SRC go
type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
#+END_SRC

Now, instead of having Sequence implement multiple interfaces (sorting and
printing), we're using the ability of a data item to be converted to multiple
types (Sequence, sort.IntSlice and []int), each of which does some part of the
job. That's more unusual in practice but can be effective.

** Interface conversions and type assertions

Type switches are a form of conversion: they take an interface and, for each
case in the switch, in a sense convert it to the type of that case. Here's a
simplified version of how the code under fmt.Printf turns a value into a string
using a type switch. If it's already a string, we want the actual string value
held by the interface, while if it has a String method we want the result of
calling the method.

#+BEGIN_SRC go
type Stringer interface {
    String() string
}

var value interface{} // Value provided by caller.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
#+END_SRC

The first case finds a concrete value; the second converts the interface into
another interface. It's perfectly fine to mix types this way.

What if there's only one type we care about? If we know the value holds a string
and we just want to extract it? A one-case type switch would do, but so would a
type assertion. A type assertion takes an interface value and extracts from it a
value of the specified explicit type. The syntax borrows from the clause opening
a type switch, but with an explicit type rather than the type keyword:

#+BEGIN_SRC go
value.(typeName)
#+END_SRC

and the result is a new value with the static type typeName. That type must
either be the concrete type held by the interface, or a second interface type
that the value can be converted to. To extract the string we know is in the
value, we could write:

#+BEGIN_SRC go
str := value.(string)
#+END_SRC

But if it turns out that the value does not contain a string, the program will
crash with a run-time error. To guard against that, use the "comma, ok" idiom to
test, safely, whether the value is a string:

#+BEGIN_SRC go
str, ok := value.(string)
if ok {
    fmt.Printf("string value is: %q\n", str)
} else {
    fmt.Printf("value is not a string\n")
}
#+END_SRC

If the type assertion fails, str will still exist and be of type string, but it
will have the zero value, an empty string.

As an illustration of the capability, here's an if-else statement that's
equivalent to the type switch that opened this section.

#+BEGIN_SRC go
if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
#+END_SRC

** Generality

If a type exists only to implement an interface and will never have exported
methods beyond that interface, there is no need to export the type itself.
Exporting just the interface makes it clear the value has no interesting
behavior beyond what is described in the interface. It also avoids the need to
repeat the documentation on every instance of a common method.

In such cases, the constructor should return an interface value rather than the
implementing type. As an example, in the hash libraries both crc32.NewIEEE and
adler32.New return the interface type hash.Hash32. Substituting the CRC-32
algorithm for Adler-32 in a Go program requires only changing the constructor
call; the rest of the code is unaffected by the change of algorithm.

A similar approach allows the streaming cipher algorithms in the various crypto
packages to be separated from the block ciphers they chain together. The Block
interface in the crypto/cipher package specifies the behavior of a block cipher,
which provides encryption of a single block of data. Then, by analogy with the
bufio package, cipher packages that implement this interface can be used to
construct streaming ciphers, represented by the Stream interface, without
knowing the details of the block encryption.

The crypto/cipher interfaces look like this:

#+BEGIN_SRC go
type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
#+END_SRC

Here's the definition of the counter mode (CTR) stream, which turns a block
cipher into a streaming cipher; notice that the block cipher's details are
abstracted away:

#+BEGIN_SRC go
// NewCTR returns a Stream that encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block's block size.
func NewCTR(block Block, iv []byte) Stream
#+END_SRC

NewCTR applies not just to one specific encryption algorithm and data source but
to any implementation of the Block interface and any Stream. Because they return
interface values, replacing CTR encryption with other encryption modes is a
localized change. The constructor calls must be edited, but because the
surrounding code must treat the result only as a Stream, it won't notice the
difference.

** Interfaces and methods

Since almost anything can have methods attached, almost anything can satisfy an
interface. One illustrative example is in the http package, which defines the
Handler interface. Any object that implements Handler can serve HTTP requests.

#+BEGIN_SRC go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
#+END_SRC

ResponseWriter is itself an interface that provides access to the methods needed
to return the response to the client. Those methods include the standard Write
method, so an http.ResponseWriter can be used wherever an io.Writer can be used.
Request is a struct containing a parsed representation of the request from the
client.

For brevity, let's ignore POSTs and assume HTTP requests are always GETs; that
simplification does not affect the way the handlers are set up. Here's a trivial
but complete implementation of a handler to count the number of times the page
is visited.

#+BEGIN_SRC go
// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
#+END_SRC

(Keeping with our theme, note how Fprintf can print to an http.ResponseWriter.)
For reference, here's how to attach such a server to a node on the URL tree.

#+BEGIN_SRC
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
#+END_SRC

But why make Counter a struct? An integer is all that's needed. (The receiver
needs to be a pointer so the increment is visible to the caller.)

#+BEGIN_SRC go
// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
#+END_SRC

What if your program has some internal state that needs to be notified that a
page has been visited? Tie a channel to the web page.

#+BEGIN_SRC go
// A channel that sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch <- req
    fmt.Fprint(w, "notification sent")
}
#+END_SRC

Finally, let's say we wanted to present on /args the arguments used when
invoking the server binary. It's easy to write a function to print the
arguments.

#+BEGIN_SRC go
func ArgServer() {
    fmt.Println(os.Args)
}
#+END_SRC

How do we turn that into an HTTP server? We could make ArgServer a method of
some type whose value we ignore, but there's a cleaner way. Since we can define
a method for any type except pointers and interfaces, we can write a method for
a function. The http package contains this code:

#+BEGIN_SRC go
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
#+END_SRC

HandlerFunc is a type with a method, ServeHTTP, so values of that type can serve
HTTP requests. Look at the implementation of the method: the receiver is a
function, f, and the method calls f. That may seem odd but it's not that
different from, say, the receiver being a channel and the method sending on the
channel.

To make ArgServer into an HTTP server, we first modify it to have the right
signature.

#+BEGIN_SRC go
// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, os.Args)
}
#+END_SRC

ArgServer now has same signature as HandlerFunc, so it can be converted to that
type to access its methods, just as we converted Sequence to IntSlice to access
IntSlice.Sort. The code to set it up is concise:

#+BEGIN_SRC go
http.Handle("/args", http.HandlerFunc(ArgServer))
#+END_SRC

When someone visits the page /args, the handler installed at that page has value
ArgServer and type HandlerFunc. The HTTP server will invoke the method ServeHTTP
of that type, with ArgServer as the receiver, which will in turn call ArgServer
(via the invocation f(w, req) inside HandlerFunc.ServeHTTP). The arguments will
then be displayed.

In this section we have made an HTTP server from a struct, an integer, a
channel, and a function, all because interfaces are just sets of methods, which
can be defined for (almost) any type.
