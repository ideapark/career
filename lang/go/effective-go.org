#+TITLE: Effective Go
#+AUTHOR: p@ctriple.cn

* Effective Go :TOC_4_gh:noexport:
- [[#introduction][Introduction]]
  - [[#examples][Examples]]
- [[#formatting][Formatting]]
- [[#commentary][Commentary]]
- [[#names][Names]]
  - [[#package-names][Package names]]
  - [[#getters][Getters]]
  - [[#interface-names][Interface names]]
  - [[#mixedcaps][MixedCaps]]
- [[#semicolons][Semicolons]]
- [[#control-structures][Control structures]]
  - [[#if][If]]
  - [[#redeclaration-and-reassignment][Redeclaration and reassignment]]
  - [[#for][For]]
  - [[#switch][Switch]]
  - [[#type-switch][Type switch]]
- [[#functions][Functions]]
  - [[#multiple-return-values][Multiple return values]]
  - [[#named-result-parameters][Named result parameters]]
  - [[#defer][Defer]]

* Introduction

Go is a new language. Although it borrows ideas from existing languages, it has
unusual properties that make effective Go programs different in character from
programs written in its relatives. A straightforward translation of a C++ or
Java program into Go is unlikely to produce a satisfactory result—Java programs
are written in Java, not Go. On the other hand, thinking about the problem from
a Go perspective could produce a successful but quite different program. In
other words, to write Go well, it's important to understand its properties and
idioms. It's also important to know the established conventions for programming
in Go, such as naming, formatting, program construction, and so on, so that
programs you write will be easy for other Go programmers to understand.

This document gives tips for writing clear, idiomatic Go code. It augments the
language specification, the Tour of Go, and How to Write Go Code, all of which
you should read first.

** Examples

The Go package sources are intended to serve not only as the core library but
also as examples of how to use the language. Moreover, many of the packages
contain working, self-contained executable examples you can run directly from
the golang.org web site, such as this one (if necessary, click on the word
"Example" to open it up). If you have a question about how to approach a problem
or how something might be implemented, the documentation, code and examples in
the library can provide answers, ideas and background.

* Formatting

Formatting issues are the most contentious but the least consequential. People
can adapt to different formatting styles but it's better if they don't have to,
and less time is devoted to the topic if everyone adheres to the same style. The
problem is how to approach this Utopia without a long prescriptive style guide.

With Go we take an unusual approach and let the machine take care of most
formatting issues. The gofmt program (also available as go fmt, which operates
at the package level rather than source file level) reads a Go program and emits
the source in a standard style of indentation and vertical alignment, retaining
and if necessary reformatting comments. If you want to know how to handle some
new layout situation, run gofmt; if the answer doesn't seem right, rearrange
your program (or file a bug about gofmt), don't work around it.

As an example, there's no need to spend time lining up the comments on the
fields of a structure. Gofmt will do that for you. Given the declaration

#+BEGIN_SRC go
type T struct {
    name string // name of the object
    value int // its value
}
#+END_SRC

gofmt will line up the columns:

#+BEGIN_SRC go
type T struct {
    name    string // name of the object
    value   int    // its value
}
#+END_SRC

All Go code in the standard packages has been formatted with gofmt.

Some formatting details remain. Very briefly:

Indentation
    We use tabs for indentation and gofmt emits them by default. Use spaces only
    if you must.
Line length
    Go has no line length limit. Don't worry about overflowing a punched card.
    If a line feels too long, wrap it and indent with an extra tab.
Parentheses
    Go needs fewer parentheses than C and Java: control structures (if, for,
    switch) do not have parentheses in their syntax. Also, the operator
    precedence hierarchy is shorter and clearer, so

#+BEGIN_SRC go
x<<8 + y<<16
#+END_SRC

means what the spacing implies, unlike in the other languages.

* Commentary

Go provides C-style /* */ block comments and C++-style // line comments. Line
comments are the norm; block comments appear mostly as package comments, but are
useful within an expression or to disable large swaths of code.

The program—and web server—godoc processes Go source files to extract
documentation about the contents of the package. Comments that appear before
top-level declarations, with no intervening newlines, are extracted along with
the declaration to serve as explanatory text for the item. The nature and style
of these comments determines the quality of the documentation godoc produces.

Every package should have a package comment, a block comment preceding the
package clause. For multi-file packages, the package comment only needs to be
present in one file, and any one will do. The package comment should introduce
the package and provide information relevant to the package as a whole. It will
appear first on the godoc page and should set up the detailed documentation that
follows.

#+BEGIN_SRC go
/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
#+END_SRC

If the package is simple, the package comment can be brief.

#+BEGIN_SRC go
// Package path implements utility routines for
// manipulating slash-separated filename paths.
#+END_SRC

Comments do not need extra formatting such as banners of stars. The generated
output may not even be presented in a fixed-width font, so don't depend on
spacing for alignment—godoc, like gofmt, takes care of that. The comments are
uninterpreted plain text, so HTML and other annotations such as _this_ will
reproduce verbatim and should not be used. One adjustment godoc does do is to
display indented text in a fixed-width font, suitable for program snippets. The
package comment for the fmt package uses this to good effect.

Depending on the context, godoc might not even reformat comments, so make sure
they look good straight up: use correct spelling, punctuation, and sentence
structure, fold long lines, and so on.

Inside a package, any comment immediately preceding a top-level declaration
serves as a doc comment for that declaration. Every exported (capitalized) name
in a program should have a doc comment.

Doc comments work best as complete sentences, which allow a wide variety of
automated presentations. The first sentence should be a one-sentence summary
that starts with the name being declared.

#+BEGIN_SRC go
// Compile parses a regular expression and returns, if successful,
// a Regexp that can be used to match against text.
func Compile(str string) (*Regexp, error) {
#+END_SRC

If every doc comment begins with the name of the item it describes, the output
of godoc can usefully be run through grep. Imagine you couldn't remember the
name "Compile" but were looking for the parsing function for regular
expressions, so you ran the command,

#+BEGIN_SRC shell
$ godoc regexp | grep -i parse
#+END_SRC

If all the doc comments in the package began, "This function...", grep wouldn't
help you remember the name. But because the package starts each doc comment with
the name, you'd see something like this, which recalls the word you're looking
for.

#+BEGIN_SRC shell
$ godoc regexp | grep parse
    Compile parses a regular expression and returns, if successful, a Regexp
    parsed. It simplifies safe initialization of global variables holding
    cannot be parsed. It simplifies safe initialization of global variables
$
#+END_SRC

Go's declaration syntax allows grouping of declarations. A single doc comment
can introduce a group of related constants or variables. Since the whole
declaration is presented, such a comment can often be perfunctory.

#+BEGIN_SRC go
// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
#+END_SRC

Grouping can also indicate relationships between items, such as the fact that a
set of variables is protected by a mutex.

#+BEGIN_SRC go
var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
#+END_SRC

* Names

Names are as important in Go as in any other language. They even have semantic
effect: the visibility of a name outside a package is determined by whether its
first character is upper case. It's therefore worth spending a little time
talking about naming conventions in Go programs.

** Package names

When a package is imported, the package name becomes an accessor for the
contents. After

#+BEGIN_SRC go
import "bytes"
#+END_SRC

the importing package can talk about bytes.Buffer. It's helpful if everyone
using the package can use the same name to refer to its contents, which implies
that the package name should be good: short, concise, evocative. By convention,
packages are given lower case, single-word names; there should be no need for
underscores or mixedCaps. Err on the side of brevity, since everyone using your
package will be typing that name. And don't worry about collisions a priori. The
package name is only the default name for imports; it need not be unique across
all source code, and in the rare case of a collision the importing package can
choose a different name to use locally. In any case, confusion is rare because
the file name in the import determines just which package is being used.

Another convention is that the package name is the base name of its source
directory; the package in src/encoding/base64 is imported as "encoding/base64"
but has name base64, not encoding_base64 and not encodingBase64.

The importer of a package will use the name to refer to its contents, so
exported names in the package can use that fact to avoid stutter. (Don't use the
import . notation, which can simplify tests that must run outside the package
they are testing, but should otherwise be avoided.) For instance, the buffered
reader type in the bufio package is called Reader, not BufReader, because users
see it as bufio.Reader, which is a clear, concise name. Moreover, because
imported entities are always addressed with their package name, bufio.Reader
does not conflict with io.Reader. Similarly, the function to make new instances
of ring.Ring—which is the definition of a constructor in Go—would normally be
called NewRing, but since Ring is the only type exported by the package, and
since the package is called ring, it's called just New, which clients of the
package see as ring.New. Use the package structure to help you choose good
names.

Another short example is once.Do; once.Do(setup) reads well and would not be
improved by writing once.DoOrWaitUntilDone(setup). Long names don't
automatically make things more readable. A helpful doc comment can often be more
valuable than an extra long name.

** Getters

Go doesn't provide automatic support for getters and setters. There's nothing
wrong with providing getters and setters yourself, and it's often appropriate to
do so, but it's neither idiomatic nor necessary to put Get into the getter's
name. If you have a field called owner (lower case, unexported), the getter
method should be called Owner (upper case, exported), not GetOwner. The use of
upper-case names for export provides the hook to discriminate the field from the
method. A setter function, if needed, will likely be called SetOwner. Both names
read well in practice:

#+BEGIN_SRC go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
#+END_SRC

** Interface names

By convention, one-method interfaces are named by the method name plus an -er
suffix or similar modification to construct an agent noun: Reader, Writer,
Formatter, CloseNotifier etc.

There are a number of such names and it's productive to honor them and the
function names they capture. Read, Write, Close, Flush, String and so on have
canonical signatures and meanings. To avoid confusion, don't give your method
one of those names unless it has the same signature and meaning. Conversely, if
your type implements a method with the same meaning as a method on a well-known
type, give it the same name and signature; call your string-converter method
String not ToString.

** MixedCaps

Finally, the convention in Go is to use MixedCaps or mixedCaps rather than
underscores to write multiword names.

* Semicolons

Like C, Go's formal grammar uses semicolons to terminate statements, but unlike
in C, those semicolons do not appear in the source. Instead the lexer uses a
simple rule to insert semicolons automatically as it scans, so the input text is
mostly free of them.

The rule is this. If the last token before a newline is an identifier (which
includes words like int and float64), a basic literal such as a number or string
constant, or one of the tokens

#+BEGIN_SRC go
break continue fallthrough return ++ -- ) }
#+END_SRC

the lexer always inserts a semicolon after the token. This could be summarized
as, “if the newline comes after a token that could end a statement, insert a
semicolon”.

A semicolon can also be omitted immediately before a closing brace, so a
statement such as

#+BEGIN_SRC go
go func() { for { dst <- <-src } }()
#+END_SRC

needs no semicolons. Idiomatic Go programs have semicolons only in places such
as for loop clauses, to separate the initializer, condition, and continuation
elements. They are also necessary to separate multiple statements on a line,
should you write code that way.

One consequence of the semicolon insertion rules is that you cannot put the
opening brace of a control structure (if, for, switch, or select) on the next
line. If you do, a semicolon will be inserted before the brace, which could
cause unwanted effects. Write them like this

#+BEGIN_SRC go
if i < f() {
    g()
}
#+END_SRC

not like this

#+BEGIN_SRC go
if i < f()  // wrong!
{           // wrong!
    g()
}
#+END_SRC

* Control structures

The control structures of Go are related to those of C but differ in important
ways. There is no do or while loop, only a slightly generalized for; switch is
more flexible; if and switch accept an optional initialization statement like
that of for; break and continue statements take an optional label to identify
what to break or continue; and there are new control structures including a type
switch and a multiway communications multiplexer, select. The syntax is also
slightly different: there are no parentheses and the bodies must always be
brace-delimited.

** If

In Go a simple if looks like this:

#+BEGIN_SRC go
if x > 0 {
    return y
}
#+END_SRC

Mandatory braces encourage writing simple if statements on multiple lines. It's
good style to do so anyway, especially when the body contains a control
statement such as a return or break.

Since if and switch accept an initialization statement, it's common to see one
used to set up a local variable.

#+BEGIN_SRC go
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
#+END_SRC

In the Go libraries, you'll find that when an if statement doesn't flow into the
next statement—that is, the body ends in break, continue, goto, or return—the
unnecessary else is omitted.

#+BEGIN_SRC go
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
#+END_SRC

This is an example of a common situation where code must guard against a
sequence of error conditions. The code reads well if the successful flow of
control runs down the page, eliminating error cases as they arise. Since error
cases tend to end in return statements, the resulting code needs no else
statements.

#+BEGIN_SRC go
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
#+END_SRC

** Redeclaration and reassignment

An aside: The last example in the previous section demonstrates a detail of how
the := short declaration form works. The declaration that calls os.Open reads,

#+BEGIN_SRC go
f, err := os.Open(name)
#+END_SRC

This statement declares two variables, f and err. A few lines later, the call to
f.Stat reads,

#+BEGIN_SRC go
d, err := f.Stat()
#+END_SRC

which looks as if it declares d and err. Notice, though, that err appears in
both statements. This duplication is legal: err is declared by the first
statement, but only re-assigned in the second. This means that the call to
f.Stat uses the existing err variable declared above, and just gives it a new
value.

In a := declaration a variable v may appear even if it has already been
declared, provided:

    1) this declaration is in the same scope as the existing declaration of v
       (if v is already declared in an outer scope, the declaration will create
       a new variable §),
    2) the corresponding value in the initialization is assignable to v, and
    3) there is at least one other variable in the declaration that is being
       declared anew.

This unusual property is pure pragmatism, making it easy to use a single err
value, for example, in a long if-else chain. You'll see it used often.

§ It's worth noting here that in Go the scope of function parameters and return
values is the same as the function body, even though they appear lexically
outside the braces that enclose the body.

** For

The Go for loop is similar to—but not the same as—C's. It unifies for and while
and there is no do-while. There are three forms, only one of which has
semicolons.

#+BEGIN_SRC go
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
#+END_SRC

Short declarations make it easy to declare the index variable right in the loop.

#+BEGIN_SRC go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
#+END_SRC

If you're looping over an array, slice, string, or map, or reading from a
channel, a range clause can manage the loop.

#+BEGIN_SRC go
for key, value := range oldMap {
    newMap[key] = value
}
#+END_SRC

If you only need the first item in the range (the key or index), drop the
second:

#+BEGIN_SRC go
for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
#+END_SRC

If you only need the second item in the range (the value), use the blank
identifier, an underscore, to discard the first:

#+BEGIN_SRC go
sum := 0
for _, value := range array {
    sum += value
}
#+END_SRC

The blank identifier has many uses, as described in a later section.

For strings, the range does more work for you, breaking out individual Unicode
code points by parsing the UTF-8. Erroneous encodings consume one byte and
produce the replacement rune U+FFFD. (The name (with associated builtin type)
rune is Go terminology for a single Unicode code point. See the language
specification for details.) The loop

#+BEGIN_SRC go
for pos, char := range "日本\x80語" { // \x80 is an illegal UTF-8 encoding
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
#+END_SRC

prints

#+BEGIN_SRC go
character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
#+END_SRC

Finally, Go has no comma operator and ++ and -- are statements not expressions.
Thus if you want to run multiple variables in a for you should use parallel
assignment (although that precludes ++ and --).

#+BEGIN_SRC go
// Reverse a
for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
#+END_SRC

** Switch

Go's switch is more general than C's. The expressions need not be constants or
even integers, the cases are evaluated top to bottom until a match is found, and
if the switch has no expression it switches on true. It's therefore possible—and
idiomatic—to write an if-else-if-else chain as a switch.

#+BEGIN_SRC go
func unhex(c byte) byte {
    switch {
    case '0' <= c && c <= '9':
        return c - '0'
    case 'a' <= c && c <= 'f':
        return c - 'a' + 10
    case 'A' <= c && c <= 'F':
        return c - 'A' + 10
    }
    return 0
}
#+END_SRC

There is no automatic fall through, but cases can be presented in
comma-separated lists.

#+BEGIN_SRC go
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&', '=', '#', '+', '%':
        return true
    }
    return false
}
#+END_SRC

Although they are not nearly as common in Go as some other C-like languages,
break statements can be used to terminate a switch early. Sometimes, though,
it's necessary to break out of a surrounding loop, not the switch, and in Go
that can be accomplished by putting a label on the loop and "breaking" to that
label. This example shows both uses.

#+BEGIN_SRC go
Loop:
	for n := 0; n < len(src); n += size {
		switch {
		case src[n] < sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] < sizeTwo:
			if n+1 >= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]<<shift)
		}
	}
#+END_SRC

Of course, the continue statement also accepts an optional label but it applies
only to loops.

To close this section, here's a comparison routine for byte slices that uses two
switch statements:

#+BEGIN_SRC go
// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a < b, and +1 if a > b
func Compare(a, b []byte) int {
    for i := 0; i < len(a) && i < len(b); i++ {
        switch {
        case a[i] > b[i]:
            return 1
        case a[i] < b[i]:
            return -1
        }
    }
    switch {
    case len(a) > len(b):
        return 1
    case len(a) < len(b):
        return -1
    }
    return 0
}
#+END_SRC

** Type switch

A switch can also be used to discover the dynamic type of an interface variable.
Such a type switch uses the syntax of a type assertion with the keyword type
inside the parentheses. If the switch declares a variable in the expression, the
variable will have the corresponding type in each clause. It's also idiomatic to
reuse the name in such cases, in effect declaring a new variable with the same
name but a different type in each case.

#+BEGIN_SRC go
var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("unexpected type %T\n", t)     // %T prints whatever type t has
case bool:
    fmt.Printf("boolean %t\n", t)             // t has type bool
case int:
    fmt.Printf("integer %d\n", t)             // t has type int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t has type *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t has type *int
}
#+END_SRC

* Functions

** Multiple return values

One of Go's unusual features is that functions and methods can return multiple
values. This form can be used to improve on a couple of clumsy idioms in C
programs: in-band error returns such as -1 for EOF and modifying an argument
passed by address.

In C, a write error is signaled by a negative count with the error code secreted
away in a volatile location. In Go, Write can return a count and an error:
“Yes, you wrote some bytes but not all of them because you filled the device”.
The signature of the Write method on files from package os is:

#+BEGIN_SRC go
func (file *File) Write(b []byte) (n int, err error)
#+END_SRC

and as the documentation says, it returns the number of bytes written and a
non-nil error when n != len(b). This is a common style; see the section on error
handling for more examples.

A similar approach obviates the need to pass a pointer to a return value to
simulate a reference parameter. Here's a simple-minded function to grab a number
from a position in a byte slice, returning the number and the next position.

#+BEGIN_SRC go
func nextInt(b []byte, i int) (int, int) {
    for ; i < len(b) && !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i < len(b) && isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
#+END_SRC

You could use it to scan the numbers in an input slice b like this:

#+BEGIN_SRC go
    for i := 0; i < len(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
#+END_SRC

** Named result parameters

The return or result "parameters" of a Go function can be given names and used
as regular variables, just like the incoming parameters. When named, they are
initialized to the zero values for their types when the function begins; if the
function executes a return statement with no arguments, the current values of
the result parameters are used as the returned values.

The names are not mandatory but they can make code shorter and clearer: they're
documentation. If we name the results of nextInt it becomes obvious which
returned int is which.

#+BEGIN_SRC go
func nextInt(b []byte, pos int) (value, nextPos int) {
#+END_SRC

Because named results are initialized and tied to an unadorned return, they can
simplify as well as clarify. Here's a version of io.ReadFull that uses them
well:

#+BEGIN_SRC go
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
#+END_SRC

** Defer

Go's defer statement schedules a function call (the deferred function) to be run
immediately before the function executing the defer returns. It's an unusual but
effective way to deal with situations such as resources that must be released
regardless of which path a function takes to return. The canonical examples are
unlocking a mutex or closing a file.

#+BEGIN_SRC go
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
#+END_SRC

Deferring a call to a function such as Close has two advantages. First, it
guarantees that you will never forget to close the file, a mistake that's easy
to make if you later edit the function to add a new return path. Second, it
means that the close sits near the open, which is much clearer than placing it
at the end of the function.

The arguments to the deferred function (which include the receiver if the
function is a method) are evaluated when the defer executes, not when the call
executes. Besides avoiding worries about variables changing values as the
function executes, this means that a single deferred call site can defer
multiple function executions. Here's a silly example.

#+BEGIN_SRC go
for i := 0; i < 5; i++ {
    defer fmt.Printf("%d ", i)
}
#+END_SRC

Deferred functions are executed in LIFO order, so this code will cause 4 3 2 1 0
to be printed when the function returns. A more plausible example is a simple
way to trace function execution through the program. We could write a couple of
simple tracing routines like this:

#+BEGIN_SRC go
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
#+END_SRC

We can do better by exploiting the fact that arguments to deferred functions are
evaluated when the defer executes. The tracing routine can set up the argument
to the untracing routine. This example:

#+BEGIN_SRC go
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
#+END_SRC

prints

#+BEGIN_SRC shell
entering: b
in b
entering: a
in a
leaving: a
leaving: b
#+END_SRC

For programmers accustomed to block-level resource management from other
languages, defer may seem peculiar, but its most interesting and powerful
applications come precisely from the fact that it's not block-based but
function-based. In the section on panic and recover we'll see another example of
its possibilities.
